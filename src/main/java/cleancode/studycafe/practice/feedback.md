### AccessPassType 또한 중요한 객체이다. 검증 메서드를 해당 클래스 위치에 두면 자연스러워 질 수 있다.
- 입장권 파일을 읽어들일 때 간단한 유효성 검증 로직을 구현했는데 이 과정이 한 클래스(AccessPass) 내에서 보기 좋게 정돈되었으면 좋겠다는 생각이 있었다.
- 따라서 AccessPass 생성자 내부에 검증하는 private 메서드를 만들었었는데, enum타입인 AccessPassType의 이름을 검증하는 로직이 어색해서 피드백을 요청했었다.
- 검증 로직에서 새로운 사용자 정의 예외를 던지도록 했기 때문에 valueOf()를 직접적으로 못쓰게 됨 -> AccessPass 클래스에서 try-catch를 통해 예외를 바꿔 던지도록 구현하여 어색했던것
- AccessPassType도 중요한 객체이다. 해당 객체에 대한 검증 메소드는 그 클래스 내부에서 하는 것이 옳다
- 해결 : 예외 바꾸는 부분을 AccessPassType로 옮김 & 검증을 정적 팩토리 메소드에서 진행

- 작업한 내용 : 
https://github.com/aammddkkzxc/readable-code/commit/5a01b29917aa24cbba16d21911e3b1ecd0d2010b

### 정적 팩토리를 쓰는 이유를 다시 상기하자. 생성자에서 의미 부여를 수행하지 않는다.
- **LockerPass를 사용할 수 없음**을 표현하기 위해 null, Optional대신 새로운 enum클래스(LockerPassType)로 관리하는 것은 나쁘지 않은 선택일 수 있다.
- 비지니스 로직이 입장권의 타입(AccessPassType)에 따라 LockerPass가 정해지기 때문에 해당 로직(LockerPasses.findLockerPassBy(~)) 수행 시 발권 불가한 LockerPass를 반환해 줄 필요가 있다(null을 사용하지 않으려면)
- 발권 불가한 LockerPass를 표현하기 위해 생성자 오버로딩과 정적 팩토리 메서드를 사용했었고 다른 사람이 보기에 불편하지 않을까 생각하여 피드백을 요청했었다.
- 정적 팩토리의 강력한 점은 네이밍을 부여하여 역할을 명확히 할 수 있다는 점이다.
- 해결 : 발권 불가한 LockerPass에 필요한 값을 할당할 때(UNAVAILABLE_PROPERTY) 생성자에서 해주었는데, 이를 정적 팩토리 메서드 내부에서 하도록 리팩토링했다.
- 결과적으로 무엇을 위한 생성자들 인지 파악할 필요가 많이 줄어들었다.

- 작업한 내용 : 
https://github.com/aammddkkzxc/readable-code/commit/3464bf84346c54d4d8705537519943390bf61550

### 그외의 피드백 내용들
- get~/set~ 으로 표현되는 메소드는 관용적으로 getter나 setter를 상기시키게 된다. 따라서 해당 접두사를 다른 용도(getter/setter 목적 외)의 메소드 네이밍에서 사용하지 않도록 하자 
- 코드 리뷰는 맞다/틀리다 형태로 진행 되지 않는다
  - 나는 ~~ 이렇게 하는 것이 맞을까요? 이런 식의 피드백 요청을 많이 남겼었다
  - 지금 와서 생각해보면 나름 원칙을 가지고 구현했었지만, 확신할 수 없었고 정답을 정해줬으면 하는 마음이 있었던 것 같다.
  - 실제로 일할 때 코드 리뷰 후 제품에 반영이 된다고 생각해 보았다.
  - 그렇다면 코드 리뷰 과정은 정답 맞추기 라기 보다, 합의하는 과정이라고 생각하는 것이 더 적합할 것 같다.
  - 명확한 의도를 가지고 구현/리팩토링 하되, 요구사항이나 합의가 변하면 언제든 변경할 수 있는 자세를 지녀야 겠다.
- 일급 컬렉션 두개를 하나의 클래스에 갖는 것은 과도한가
  - 이 전 항목과 이어지는 내용. 쓰고 싶으면 쓰면 된다. 다만 명확한 이유가 있어야함.
  - 일급 컬렉션이라는 용어 자체에 집중하지 말고 왜 쓰는지에 집중하자
