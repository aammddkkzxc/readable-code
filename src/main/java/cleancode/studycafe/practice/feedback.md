### AccessPassType 또한 중요한 객체이다. 검증 메서드를 해당 클래스 위치에 두면 자연스러워 질 수 있다.
- 입장권 파일을 읽어들일 때 간단한 유효성 검증 로직을 구현했는데 이 과정이 한 클래스(AccessPass) 내에서 보기 좋게 정돈되었으면 좋겠다는 생각이 있었다.
- 따라서 AccessPass 생성자 내부에 검증하는 private 메서드를 만들었었는데, enum타입인 AccessPassType의 이름을 검증하는 로직이 어색해서 피드백을 요청했었다.
- 검증 로직에서 새로운 사용자 정의 예외를 던지도록 했기 때문에 valueOf()를 직접적으로 못쓰게 됨 -> AccessPass 클래스에서 try-catch를 통해 예외를 바꿔 던지도록 구현하여 어색했던것
- AccessPassType도 중요한 객체이다. 해당 객체에 대한 검증 메소드는 그 클래스 내부에서 하는 것이 옳다
- 해결 : 예외 바꾸는 부분을 AccessPassType로 옮김 & 검증을 정적 팩토리 메소드에서 진행

### 정적 팩토리를 쓰는 이유를 다시 상기하자. 생성자에서 의미 부여를 수행하지 않는다.
- **LockerPass를 사용할 수 없음**을 표현하기 위해 null, Optional대신 새로운 enum클래스(LockerPassType)로 관리하는 것은 나쁘지 않은 선택일 수 있다.
- 비지니스 로직이 입장권의 타입(AccessPassType)에 따라 LockerPass가 정해지기 때문에 해당 로직(LockerPasses.findLockerPassBy(~)) 수행 시 발권 불가한 LockerPass를 반환해 줄 필요가 있다(null을 사용하지 않으려면)
- 발권 불가한 LockerPass를 표현하기 위해 생성자 오버로딩과 정적 팩토리 메서드를 사용했었고 다른 사람이 보기에 불편하지 않을까 생각하여 피드백을 요청했었다.
- 정적 팩토리의 강력한 점은 네이밍을 부여하여 역할을 명확히 할 수 있다는 점이다.
- 해결 : 발권 불가한 LockerPass에 필요한 값을 할당할 때(UNAVAILABLE_PROPERTY) 생성자에서 해주었는데, 이를 정적 팩토리 메서드 내부에서 하도록 리팩토링했다.
- 결과적으로 무엇을 위한 생성자들 인지 파악할 필요가 많이 줄어들었다.